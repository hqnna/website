---
.title = "Securing Access",
.description = "Securing access to Linux servers using multiple tools",
.layout = "post.shtml",
.author = "Hanna Rose",
.date = "2025-07-04",
.draft = true
---

One of the first things I do when buying any kind of root server, that being
either a VPS or Dedicated server, is to secure access to it. I often do this
using multiple tools, so I wanted to write a post detailing how I do that, so
that hopefully other people getting into system administration have some ideas
of how they can tighten security on their own server and/or cloud infrastructure.

## Basic Tool Overview

To get things started I will be discussing the tools I often use. There's many
tools and approaches to do the things I do, so keep in mind this is just how I
do it, and you can do your own research and decide how you would prefer to do
it on your own systems within your infrastructure or setup.

### VPN Tunnels

One thing I often do is lock things that need to be secured or private behind a
VPN, there's multiple VPN software that can do this, and when I say VPN I do not
mean one that is made to enforce privacy. We're using VPNs as they are intended,
as a way to create a private internal network for things we do not want exposed
to the public internet, also known as an "intranet."

The main VPNs I have used for my infrastructure are the following:

- [Wireguard](https://wireguard.com) is an open source VPN software and protocol.
- [Tailscale](https://tailscale.com) is a hosted VPN with an easy-to-setup approach.
- [Netbird](https://netbird.io) is a good alternative to Tailscale with roughly the same.

I'm going to be focusing on **Wireguard** in this post because that is what I
am currently using on my server(s). So if you would prefer to use either
Tailscale or Netbird, I would recommend looking those up and doing your own
research on how to set them up and secure servers using them.

### SSH Key Types

There is many different types of SSH key types but the one I usually prefer is
**ED25519** for multiple reasons. For one, they are supposedly quantum-safe due
to the fact they use elliptic curve algos. For two, the keys are quite small
allowing them to be very portable and easy to pass around to people and paste
in terminals and files. As a simple example, here is my public key:

```
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIEST6MgqRSn0N9ResAQ6Alt0V02GJF3XWneEDeheuQVI
```

As you can see, it is quite small, which is nice compared to RSA or other types
of SSH keys. Of course you do not have to use ED25519, but it is the type of key
that I would personally recommend using due to it being quantum-safe and easy to
distribute to other users or servers.

### Firewalls

There is many different firewalls, the ones I have the most experience with however
are probably UFW, Firewalld, and NixOS' built-in firewall. However for the
more experienced there are things like Opnsense and Pfsense which are BSD distros
made to act as firewalls themselves. If you are a beginner and want easy to setup
firewalls, I'd recommend staying away from the distros and instead go for the other
firewalls that you can simply install as a package on your Linux systems. For the
more experienced though, you can go for the BSD distros as they give you more power.

I will be focusing on **UFW** in this guide, but of course you do not have to use
what I use, a lot of people dislike UFW due to how simple it is, it's not very
flexible, and it's not really meant to be. So if you are fine with that, continue
reading and we'll get to configuring everything my way.

## Setting Up A Tunnel

The first thing we're going to do is use **Wireguard** to setup a VPN tunnel so
that our internal or private services have a private interface to use that
isn't publicly accessible. Assuming you're on Ubuntu (or Debian) we can
install Wireguard using the following commands on your server:

```
sudo apt update
sudo apt install -y wireguard-tools
```

This will update the package database and then install the `wireguard-tools`
package which contains Wireguard itself and all of the packages needed for
it to work. After installing we'll want to setup the actual tunnel interface,
we can do this pretty easy with Wireguard by creating a configuration file.

```ini
[Interface]
PrivateKey = ; Private Key Here
Address = ; Interal IP here
ListenPort = 51820

[Peer]
PublicKey = ; Public Key Here
AllowedIPs = ; Allowed Internal IPs
```

As you can see the server-side tunnel configuration is pretty simple, we'll go
over filling each field as necessary over the course of this section. To get us
started let's focus on the keys. To create a private key we want to run the
following command on the server using a terminal:

```
wg genkey > /etc/wireguard/private.key
```

This will generate a **private** key and store it in a `private.key` file. Now
run the following as well:

```
cat /etc/wireguard/private.key | wg pubkey > /etc/wireguard/public.key
```

This will generate a **public** key from the **private** key and store it. You
will want to keep the public key for use later when we create a client
config for the tunnel. So now that we have our keypair, we're going to
fill in the interface fields of our server config, here is an example:

```ini
[Interface]
PrivateKey = AKmIKLDtZjBru+aVJOn1WK2oXGlEFLCYlJIxEFZWa1M=
Address = 192.168.1.1/32
ListenPort = 51820
```

To explain what each field does in this section to make it easier to understand:

- `PrivateKey` is your **server** private key, the one we just generated and stored in a file.
- `Address` is the **internal** loopback address we want to give the Wireguard VPN tunnel.
- `ListenPort` is the port the tunnel will listen on for VPN traffic, **it needs to be exposed**.

Once these fields have been filled in we can continue to doing the `Peer`
section of the config which is for the client, aka, your own computer; but
first we need to create the client config locally:

```ini
[Interface]
PrivateKey = ; Client private key here
Address = ; Client address here

[Peer]
PublicKey = ; Server public key here
EndPoint = ; Server public address here
AllowedIPs = ; Server private address here
PersistentKeepalive = 20
```

You will need to run the previous two commands mentioned earlier to generate
keys on your own computer this time, these will be used as the client keypair.
We will start with the `Peer` section since we already have the needed details.
A finished `Peer` section would for example look like:

```ini
[Peer]
PublicKey = 6FNv8x0o6O7ckn47ELXtb6qDNN+5P2epJoXOFGGmtgQ=
EndPoint = 232.111.222.151:51820
AllowedIPs = 192.168.1.1/32
PersistentKeepalive = 20
```

A brief description of what each field does in this section would be, for example:

- `PublicKey` is the **server** public key that we generated in the earlier steps on the server.
- `Endpoint` is the **server** public address and the VPN port, this would be the exposed one.
- `AllowedIPs` is a netmask of allowed VPN addresses, these ones you assign to your tunnel.
- `PersistentKeepalive` tells Wireguard how many seconds to keep a connection alive.

Given this knowledge you should be able to fill in the other sections, but here are examples:

```ini
; Server Wireguard Config
; Located in /etc/wireguard/tunnel.conf

[Interface]
PrivateKey = AKmIKLDtZjBru+aVJOn1WK2oXGlEFLCYlJIxEFZWa1M=
Address = 192.168.1.1/32
ListenPort = 51820

[Peer]
PublicKey = 7E+1ccNueJqkFQEkmSfDfqU1dyQbHSqoJCmOxvROBg8=
AllowedIPs = 192.168.1.0/24
```

```ini
; Client Wireguard Config
; Downloaded on your own computer

[Interface]
PrivateKey = qArJ2BddEkugK0Hg/qrgepFiS3sDLMeGcsYgd74eG2o=
Address = 192.168.1.2/32

[Peer]
PublicKey = 6FNv8x0o6O7ckn47ELXtb6qDNN+5P2epJoXOFGGmtgQ=
EndPoint = 232.111.222.151:51820
AllowedIPs = 192.168.1.1/32
PersistentKeepalive = 20
```

After setting up these configuration files on their respective systems, you
can start the tunnel on the server by running the following command, assuming
your system has systemd for services:

```
systemctl enable --now wg-quick@tunnel.service
```

This will automatically enable the tunnel on boot and start it. Lastly, to
connect to the tunnel on our own system, we would run the following command
in our preferred terminal:

```
sudo wg-quick up ~/.config/wireguard/tunnel.conf
```

Assuming everything was configured correctly... you should now have a VPN setup.
You can check to make sure by running `sudo wg show`, if the `peer` section shows
a result showing the `last handshake` and `transfer` fields, you have connected
and can move onto the next section.

## Configuring SSH Access

Now that we have a working VPN tunnel we want to configure our SSH daemon to use
it, as well as configure the types of keys we want our server to accept. To do
this we'll be configuring the daemon in two parts, the first part will cover
getting the `sshd` daemon to listen on our VPN subnet, and the second will be
configuring it to only accept our preferred key type (for me, that is ED25519).

### Changing The Listening Address

To change the address we are listening on we will need to change two files:

- `/etc/ssh/sshd_config` which contains all of the settings for the ssh server daemon.
- `/lib/systemd/system/ssh.service` which contains the systemd service configuration.

To get us started we will want to update the service to wait for the VPN tunnel to
start and add a small amount of time before sshd starts to ensure the VPN address
is available. To do this we will open the file and change two things, we do not need
to modify anything else in this file.

```diff
[Unit]
Description=OpenBSD Secure Shell server
Documentation=man:sshd(8) man:sshd_config(5)
- After=network.target nss-user-lookup.target auditd.service
+ After=network.target nss-user-lookup.target auditd.service wg-quick@tunnel.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
+ ExecStartPre=/bin/sleep 5
EnvironmentFile=-/etc/default/ssh
ExecStartPre=/usr/sbin/sshd -t
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/usr/sbin/sshd -t
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
RestartPreventExitStatus=255
Type=notify
RuntimeDirectory=sshd
RuntimeDirectoryMode=0755

[Install]
WantedBy=multi-user.target
Alias=sshd.service
```

These changes do two things: wait for the tunnel service, and add a 5 second
sleep before starting, ensuring that the VPN tunnel starts and that the tunnel's
address is actually available for use. After making these changes you will want
to run the following command to make systemd aware of the changes we just made
as it doesn't automatically see the changes unfortunately:

```
sudo systemctl daemon-reload
```

After this is done we will now be updating our ssh daemon settings to properly
listen on the address we specified in our VPN tunnel configuration in earlier
steps. To do this we will want to uncomment and change the `ListenAddress` line
in the file located at `/etc/ssh/sshd_config`.

```diff
- #ListenAddress 0.0.0.0
+ ListenAddress 192.168.1.1
```

You can optionally change the port the server listens on by uncommenting and
changing the `Port` setting, but as we are already listening on a private subnet
it isn't strictly necessary. At last, we can restart the ssh daemon and connect
to the server using the VPN tunnel. **Ensure you are properly connected to the
VPN tunnel before doing this**; Run the following command to switch over:

```
systemctl restart ssh.service
```

Assuming everything worked... you can disconnect and reconnect using the VPN tunnel:

```
ssh root@192.168.1.1
```

If this worked, you have successfully setup SSH to listen on the VPN tunnel.
